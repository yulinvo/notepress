

## 创建构造函数

```
function Person(name , age , gender){
    this.name = name;
    this.age = age;
    this.gender = gender;
    this.sayName = function(){			#应该不是写在这里的吧？  应该定义在原型链上的吧？
        alert(this.name);
    };
}

var per = new Person() 


# 使用instanceof可以检查一个对象是否是一个类的实例，如果是，则返回true，否则返回false：
    console.log(per instanceof Person);
    
# object也是顶级的类，所以任何对象和Object做instanceof检查时都会返回true
    console.log(per instanceof Object);
```



## 构造函数修改

```
构造函数每次实例化，sayName函数都会单独开辟一个内存区域，所以需要原型（原型中的函数只会占用一次空间）
function Person(name , age , gender){
    this.sayName = function(){...};
}

改为：function fun2(){...} && this.sayName = fun2;
```



## 原型对象

**每一个函数（包括普通函数），解析器都会向函数中添加一个属性prototype，如果函数作为普通函数调用prototype没有任何作用**

```
function fn1(){
	console.log('fn1....');
}
console.log('fn1:',fn1.prototype);				#普通函数也有prototype属性
```



```
Person.prototype.a = 10             #类的prototype
p1.__proto__                    	#实例的__proto__
Person.prototype == p1.__proto__		#!!!!!!!!!!!
Person.prototype.sayHello = function(){    #这种方法是不是有点傻，只能额外添加不能定义在构造函数中么？？？
	alert("hello");
};
```



### hasOwnProperty

可以使用对象的hasOwnProperty()来检查对象自身中是否含有该属性，使用该方法只有当对象自身中含有属性时，才会返回true

```
#使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true（console.log("name" in mc);）    !!!!!!
    console.log(mc.hasOwnProperty("age"));
```



## toString













