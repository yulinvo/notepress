## 创建函数

- 方式一：使用 函数声明 来创建一个函数

  ```
  语法：
  	function 函数名([形参1,形参2...形参N]){
  		语句...
  	}
  	
  	
  function fun2(){    					#这种是最常用的
  	console.log("这是我的第二个函数~~~");
  	document.write("~~~~(>_<)~~~~");
  }
  ```

  

- 方式二：使用 函数表达式 来创建一个函数

  ```
  语法：
  	var 函数名  = function([形参1,形参2...形参N]){
  	 	语句....
  	}
  
  
  var fun3 = function(){    				#将创建的匿名函数，赋值给变量fun3
  	console.log("我是匿名函数中封装的代码");
  };
  fun3();               					#调用函数
  ```

  



## 参数

```
function sum(a,b){
	console.log(a+b)
}

调用函数时，解析器也不会检查实参的数量,多余实参不会被赋值               #多的情况
	sum(123,456,"hello",true,null);     -->579         #后面的"hello",true,null会被忽略

如果实参的数量少于形参的数量，则没有对应实参的形参将是undefined         #少的情况
    sum(123);                           --> NaN        #少的实参会被赋予undefined
```



## return返回值

```
return;         #相当于return undefined;
如果函数中不写return，则也会返回undefined

var result = alert("hello");        #此时result为undefined，证明alert是没有返回值的
```



使用return可以结束整个函数，不管return是不是写在主函数中，还是写在嵌套函数中！！！



## 立即执行函数

```
语法：
    (function(){
        alert("我是一个匿名函数~~~");
    })();

示例：
    (function(a,b){
		console.log("a = "+a);
        console.log("b = "+b);
    })(123,456);                       #将123，456当作参数传递
```







## 函数作用域

### 全局作用域下声明提前

- 变量的声明提前

  ```
  - 使用var关键字声明的变量，会在所有的代码执行之前被声明（但是不会赋值）；但是如果声明变量时不使用var关键字，则变量不会被声明提前
  ```

  

- 函数的声明提前

  ```
  - 使用函数声明形式[function 函数(){}]创建的函数，会在所有的代码执行之前就被创建，所以我们可以在函数声明前来调用函数
  
  - 使用函数表达式创建的函数[var aa = function(){}]，不会被声明提前，所以不能在声明前调用
  ```



### 函数作用域下声明提前

在函数作用域中也有声明提前的特性，使用var关键字声明的变量会在函数中所有的代码执行之前被声明，**不使用var声明的变量都会成为全局变量**

```
示例一：
    var a=10;
    function fun3(){
        console.log(a);                     #此时报undefined
        var a = 35;							#如果代码是 a = 35上条语句打印的结果就是10，但是将全局的a修改了
    }                                       

    console.log(a);             #如果代码是var a = 35; 此处输出10
        #如果代码是a = 35;此处输出的是35；


示例二：
    function fun5(){
        d = 100;                                #没有全局变量d的情况下
        //d没有使用var关键字，则会设置为全局变量，相当于window.d=100
    }                  
    console.log(d);                 #此时输出100
```



**定义形参就相当于在函数作用域中声明了变量**

```
#fun(e){}就相当于在函数内部定义，var e；

没有传递参数时直接是undefined (就算全局有变量e，全局的变量e和此处的e实际没有任何关系，此时的e只是一个标识可以是abc、test、e都行)
```



**总结：函数内部声明的变量一定要写var**



### 练习

```


```





## call和apply

func.call()、func.apply()、func() 都会调用函数执行

```
call()方法可以将实参在对象之后依次传递                        #fun.call(obj,2,3);
apply()方法需要将实参封装到一个数组中统一传递                 #fun.apply(obj,[2,3]);


function fun(a,b) {
    alert(this);
}

var obj = {
    name: "obj",
    sayName:function(){
        alert(this.name);
    }
};

var obj2 = {
    name: "obj2"
};

fun.call(obj);
fun.apply(obj);

obj.sayName.apply(obj2);    	#！！！！！！！！！！
```



## arguments

```
在调用函数时，浏览器每次都会传递进两个隐含的参数：
    1.函数的上下文对象 this
    2.封装实参的对象 arguments
        - arguments是一个类数组对象,它也可以通过索引来操作数据，也可以获取长度
        - 在调用函数时，我们所传递的实参都会在arguments中保存（不管是否定义了形参）！！！
        - arguments.length可以用来获取实参的长度
        - 我们即使不定义形参，也可以通过arguments来使用实参，只不过比较麻烦
            arguments[0] 表示第一个实参
            arguments[1] 表示第二个实参 。。。
    - 它里边有一个属性叫做callee，
        这个属性对应一个函数对象，就是当前正在指向的函数的对象
        function fun(a,b){
            console.log(arguments.callee == fun)
        }
```



























