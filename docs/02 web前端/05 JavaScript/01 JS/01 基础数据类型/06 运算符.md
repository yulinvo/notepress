---
sidebarDepth: 2
---



## 算数运算符

运算符都是会返回结果的，意味着可以用变量来接收运算结果（包括typeof函数）



### 加（+）

- 当对非Number类型的值进行运算时，会将这些值转换为Number然后在运算(除了字符串的加法之外)

  ```
  true + 1 -->    2
  true + false -->    1
  2 + null  -->   2
  ```

- 任何值和NaN做运算都得NaN

  ```
  2 + NaN     -->     NaN
  ```

- 如果对两个字符串进行加法运算，则会做拼串，会将两个字符串拼接为一个字符串，并返回

  ```
  ‘123’ + ‘456’  -->    '123456'
  ```

- 任何的值和字符串做加法运算，都会先转换为字符串，然后再和字符串做拼串的操作

  ```
  如 123 + ‘1’     -->   1231
  true + 'hello'      -->     truehello
  
  我们只需要为任意的数据类型 + 一个 "" 即可将其转换为String：        #这种方式比string()的方式还多一些
  	123 + ""        #效果同string(123)
  	null + ""   -->     'null'
  ```

- 练习

  ```
  1 + 2 + '3'     -->     '33'      #从左往右运算，在chrome的console中可以看到，刚写到1+2+就先出来了结果3
  
  '1' + 2 + 3     -->     '123'
  ```



### 减（-）

```
#当对非Number类型的值进行减法运算时，会将这些值转换为Number然后在运算(包括字符串)

100 - true          -->     99
100 - '1'           -->     99
```



### 乘（*）

```
2 * '8'             -->         16
2 * undefined       -->         NaN(因为undefined转换为数字是NaN，任何值和NaN运算结果都是NaN)  ！！！！
2 * null            -->         0
```



### 除（/）







### 模运算（%）

```
取模运算（取余数）
```



### 总结

```
任何值做- * /运算时都会自动转换为Number，我们可以利用这一特点做隐式的类型转换

可以通过为一个值 -0 *1 /1来将其转换为Number，原理和Number()函数一样，使用起来更加简单
```



## 一元运算符

- 正号（+）【Number类型】

  ```
  正号不会对数字产生任何影响
  
  #如 var a=123;  a = +a;          #a不会变化，默认就是正数的123
  ```

- 负号（-）【Number类型】

  ```
  负号可以对数字进行负号的取反
  
  #如 var a=123;  a = -a;          #a变成了 -123
  #如 var a=-123;  a = -a;          #a变成了 123
  ```

- 非Number类型

  ```
  它会将先转换为Number，然后在运算
  	#var a =true; a=-a              #a变成了-1
  
  可以对一个其他的数据类型使用+,来将其转换为number    （适用于任意数字类型）
  	#var a = '18'; a=+a             #a由字符串变成了数字18
  	
  	#1 + '2' + 3     -->    字符串123
  	#1 + +'2' + 3    -->     数字6
  
  它的原理和Number()函数一样
  ```

  

## 自增（++）和自减（--）

```
var a=1  &&	a++;              #并没有执行var a=a++;  此时a已经变成2了
```



### 自增 ++

```
 - 通过自增可以使变量在自身的基础上增加1
 - 对于一个变量自增以后，原变量的值会立即自增1           #！！！！！
 
 - 自增分成两种：后++(a++) 和 前++(++a)    
	无论是a++ 还是 ++a，都会立即使原变量的值自增1
		不同的是a++ 和 ++a的值不同
	a++的值等于原变量的值（自增前的值）    #a的值都是已经加过的值，只是在print a++或是print ++a时有区别 ！！！！！！
	++a的值等于新值 （自增后的值）
	
	
	#var a =1
	a++ / ++a ;
	console.log("a++ =" + a++ /"++a =" + ++a);      #如果是a++此时是1，如果是++a此处是2         #P17 07:00
	console.log(a)                                  #不管是a++ / ++a，此处a都是2                #P17 07:00


练习：
	var d=20;
	var result = d++ + ++d + d;         #20 + 22 +22        #P17 14:00
	var d=20;
	d = d++;                #执行后d=20                      #P17 16:00
	var d=20;
	d +=1;                  #执行后d=21
```



### 自减 --

```
- 通过自减可以使变量在自身的基础上减1
- 自减分成两种：后--(a--) 和 前--(--a)
	无论是a-- 还是 --a 都会立即使原变量的值自减1
		不同的是a-- 和 --a的值不同
			a-- 是变量的原值 （自减前的值）
			--a 是变量的新值 （自减以后的值）
```



### 练习

```
var n1=10, n2=20;
var n = n1++;
console.log('n=' + n);                  //10
console.log('n1=' + n1);                 //11
n = ++n1
console.log('n=' + n);                  //12
console.log('n1=' + n1);                 //12
n = n2--
console.log('n=' + n);                  //20
console.log('n2=' + n2);                 //19
n = --n2
console.log('n=' + n);                  //18
console.log('n2=' + n2);                 //18
```



## 逻辑运算符

### 非（! ）

```
var a=true; console.log('a=' + !a)
!!a                 #两次取反(非布尔值转换为布尔值)

如果对非布尔值进行运算，则会将其转换为布尔值，然后再取反，所以我们可以利用该特点，来将一个其他的数据类型转换为布尔值
	可以为一个任意数据类型取两次反，来将其转换为布尔值，原理和Boolean()函数一样          #隐式进行布尔值转换
	
	# var a = 'hello'
	# a = !!a;              //a=true
```



### 与 (&&)

```
JS中的“与”属于短路的与，如果第一个值为false，则不会看第二个值
```

- 非布尔值的与运算

  ```
  对于非布尔值进行与或运算时，会先将其转换为布尔值，然后再运算，并且返回原值             #返回值不是true或false
  
  - 如果第一个值为true，则必然返回第二个值               #规则好像是计算到哪一步，就返回哪个值！！！！
  - 如果第一个值为false，则直接返回第一个值              #规则好像是计算到哪一步，就返回哪个值！！！！
  
  var result =  5 && 6            #如果两个值都为true，则返回后边的
  ```



### 或 (||)

```
- 两个值中只要有一个true，就返回true；如果两个值都为false，才返回false
	
- JS中的“或”属于短路的或；如果第一个值为true，则不会检查第二个值
```

- 非布尔值的或运算

  ```
  - 如果第一个值为true，则直接返回第一个值
  - 如果第一个值为false，则返回第二个值
  ```

  

## 赋值运算符

```
+= :        	a += 5 等价于 a = a + 5
-=:        		a -= 5 等价于 a = a - 5
*=:        		a *= 5 等价于 a = a * 5
/=:        		a /= 5 等价于 a = a / 5
%=:        		a %= 5 等价于 a = a % 5
```



## 关系运算符

```
> 大于号    #如果关系成立它会返回true，如果关系不成立则返回false
>= 大于等于
< 小于号
<= 小于等于

非数值的情况
    - 对于非数值进行比较时，会将其转换为数字然后在比较  (两侧至少有一个是数值，不能都是字符串)
        console.log(1 > true);          //false        #true转换为1，false转换为0
        console.log(1 > "0");           //true
        console.log(10 > null);         //true          #null转换为数字为0
        console.log(true > false);      //true          1>0
        
        #任何值和NaN做任何比较都是false
        console.log(10 <= "hello");     //false  #字符串中有非数字的内容，则转换为NaN
        console.log(10 <= "undefined");     //false     ##undefined --> 数字为NaN
        
    - 如果符号两侧的值都是字符串时，不会将其转换为数字进行比较
        而会分别比较字符串中字符的Unicode编码
        console.log("1" < "5"); //true
        console.log("11" < "5"); //true                 #参考下面的规则，先比较第一位1<5,后面的就不比较了
        
        console.log("a" < "b");//true
        
        比较字符编码时是一位一位进行比较
        如果两位一样，则比较下一位，所以借用它来对英文进行排序！！！！！！
        console.log("abc" < "b");//true                      #先比较第一位，第一位成立后面的就不比较了
        console.log("bbc" < "b");//false                     #
        console.log("abc" < "bcd");//true
        
        比较中文时没有意义
        console.log("戒" > "我"); //true
    
    经验：如果两个都是字符串，可以将一侧的字符串转换为数字之后在进行比较！！！！！
        //如果比较的两个字符串型的数字，可能会得到不可预期的结果
        //注意：在比较两个字符串型的数字时，一定一定一定要转型
        console.log("11123123123123123123" < +"5"); //true
```



## 相等运算符

### ==

```
- 当使用==来比较两个值时，如果值的类型不同，则会自动进行类型转换，将其转换为相同的类型然后在比较
    #转换成什么类型不确定，大部分情况下会转换成数字
    console.log("1" == 1);  //true
    console.log(true == "1"); //true    #将字符串和布尔值都转换成了num，再进行比较的
    console.log(null == 0); //false     #但是这个就没有都转换成num进行比较，转换的规则比较奇怪！！！！
    
	undefined 衍生自 null，所以这两个值做相等判断时，会返回true
        console.log(undefined == null);
    
	NaN不和任何值相等，包括他本身
        console.log(NaN == NaN); //false
        isNaN(b) 来判断字符串b是不是NaN类型的（NaN == NaN不能这么比较）
```



### !=

```
#不相等
```



### ===

```
- 用来判断两个值是否全等，它和相等类似，不同的是它不会做自动的类型转换
	如果两个值的类型不同，直接返回false

	console.log(null === undefined);        //false
```



### !==

```
- 用来判断两个值是否不全等，和不等类似，不同的是它不会做自动的类型转换
	如果两个值的类型不同，直接返回true
	
	console.log(1 !== "1"); //true
```



## 条件运算符（三元/三目运算符）

```
语法：条件表达式?语句1:语句2;
    var a = 300;
    var b = 143;
    var c = 50;
    
    //a > b ? alert("a大"):alert("b大");
    
    //获取a和b中的最大值
    var max = a > b ? a : b;
    
    //这种写法不推荐使用，不方便阅读               #取出a、b、c的最大值
    var max = a > b ? (a > c ? a :c) : (b > c ? b : c);

如果条件的表达式的求值结果是一个非布尔值，
    会将其转换为布尔值然后在运算
    #   "hello"?alert("语句1"):alert("语句2");
```



## 运算符的优先级

```
使用,可以分割多个语句，一般可以在声明多个变量时使用,
    var a , b , c;
    var a=1 , b=2 , c=3;
    
就和数学中一样，在JS中运算符也有优先级，比如：先乘除 后加减

在JS中有一个运算符优先级的表，    #P26  06:30，在ppt课件中有一个表格
    在表中越靠上优先级越高，优先级越高越优先计算，
    如果优先级一样，则从左往右计算。
但是这个表我们并不需要记忆，如果遇到优先级不清楚, 可以使用()来改变优先级！！！！！

var result = 1 || 2 && 3;           #与的优先级高于或的优先级，结果为1
```

