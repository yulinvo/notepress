(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{420:function(n,t,e){"use strict";e.r(t);var a=e(56),s=Object(a.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h2",{attrs:{id:"let、const"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#let、const"}},[n._v("#")]),n._v(" Let、Const")]),n._v(" "),e("p",[e("strong",[n._v("let 关键字用来声明变量，使用 let 声明的变量有几个特点：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("1) 不允许重复声明    #console界面会报错，var不会\n2) 块儿级作用域\n\t#使用var就能正确读取，let会报错(var的作用域要在复习下了！)      #03:00\n\t#使用var定义的是往window中添加的属性，？？？\n3) 不存在变量提升（即不会声明提前）\n4) 不影响作用域链\n\t{ \n\t\tlet school = '尚硅谷';\n\t\tfunction fn() { \n\t\t\tconsole.log(school);\n\t\t}\n\t\tfn();\n\t}\n应用场景：以后声明变量使用 let 就对了\n")])])]),e("p",[e("strong",[n._v("const声明常量以及特点：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("const SCHOOL = '尚硅谷';\n\nconst 关键字用来声明常量，const 声明有以下特点\n    1) 声明必须赋初始值\n    2) 标识符一般为大写（小写也可以）\n    3) 不允许重复声明\n    4) 值不允许修改       注意: 对象属性修改和数组元素变化不会触发 const 错误(因为栈内存中指向的引用地址没有发生变化)\n    5) 块儿级作用域\n    应用场景：声明对象类型使用 const ，非对象类型声明选择 let\n")])])]),e("h2",{attrs:{id:"变量的解构赋值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#变量的解构赋值"}},[n._v("#")]),n._v(" 变量的解构赋值")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("-------------------Array数组------------------------\nconst F4 = ['小沈阳','刘能','赵四','宋小宝'];\nlet [xiao, liu, zhao, song] = F4;     #要加[]，不能直接等：xiao, liu, zhao, song = F4\n\n\n--------------------obj对象-------------------------\nconst zhao = {\n    name: '赵本山',\n    age: '不详',\n    xiaopin: function(){\n        console.log(\"我可以演小品\");\n    }};\nlet {name, age, xiaopin} = zhao;    #同理要加{}，不能直接等\n#注意: \n    - 顺序无所谓： let {xiaopin, age,name} = zhao 解构出来的结果是一样的 ！！！\n    - let {a,b,c} = zhao是结构不出来的，必须和key值相等才能解构出来 ！！！！\n对象还可以单独结构赋值：\n    let {xiaopin} = zhao;    #变量xiaopin就单独结构成了函数xiaopin，可以单独调用xiaopin();\n")])])]),e("h2",{attrs:{id:"模板字符串"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模板字符串"}},[n._v("#")]),n._v(" 模板字符串")]),n._v(" "),e("p",[n._v("ES6 引入新的声明字符串的方式 『``』\t\t\t#反引号")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("- 内容中可以直接出现换行符\nlet str = `<ul>\n            <li>沈腾</li>\n            <li>玛丽</li>\n            <li>魏翔</li>\n            <li>艾伦</li>\n            </ul>`;\n\t\t\t\n\t之前的方法：\n\tlet str = '<ul>'\n\t\t\t+ '<li>沈腾</li>'\n\t\t\t+ '<li>玛丽</li>'\n\t\t\t+ '<li>魏翔</li>'\n\t\t\t+ '<li>艾伦</li>'\n\t\t\t+ '</ul>';\n\n- 变量拼接\nlet lovest = '魏翔';\nlet out = `${lovest}是我心目中最搞笑的演员!!`;\nconsole.log(out);\n")])])]),e("h2",{attrs:{id:"对象的简化写法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对象的简化写法"}},[n._v("#")]),n._v(" 对象的简化写法")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("//ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。\n//这样的书写更加简洁\nlet name = '尚硅谷';\nlet change = function(){\n    console.log('我们可以改变你!!');\n}\n\nconst school = {\n    name,                #完整写法：        name:name\n    change,                #同上\n    improve(){            #完整写法：        improve: function(){...}\n        console.log(\"我们可以提高你的技能\");\n    }\n}\n")])])]),e("h2",{attrs:{id:"箭头函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数"}},[n._v("#")]),n._v(" 箭头函数")]),n._v(" "),e("h2",{attrs:{id:"函数参数的默认值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数参数的默认值"}},[n._v("#")]),n._v(" 函数参数的默认值")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function add(a,b,c=10) {xxx}\n    #默认值通常写在最后面(只是一个潜规则，非必须)\n    function add(a,c=10,b){}，此时调用add(1,2)的时候，结果就是NaN了，因为a为1，c=2（替换掉了10），此时b没有值为NaN，相加结果就是NaN\n\n\nfunction connect({host=\"127.0.0.1\", username,password, port}){             #此时传递的参数只有一个，就是{xx} ！！！！！   这个读代码的时候很容易造成迷糊，要特别注意传递的参数是一个什么类型的！！！！\n    console.log(host)\n    console.log(username)\n    console.log(password)\n    console.log(port)\n}\nconnect({\n    host: 'atguigu.com',\n    username: 'root',\n    password: 'root',\n    port: 3306\n})\n")])])]),e("h2",{attrs:{id:"rest参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rest参数"}},[n._v("#")]),n._v(" rest参数")]),n._v(" "),e("p",[n._v("ES6 引入 rest 参数，用于获取函数的实参，用来代替 arguments（arguments是ES5的写法）")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function date(...args){\n    console.log(args);// filter some every map            #args返回的是一个数组，arguments返回的是一个object对象\n}\n\n// rest 参数必须要放到参数最后\n    function fn(a,b,...args){ xx }\n    fn(1,2,3,4,5,6);\n")])])]),e("h2",{attrs:{id:"扩展运算符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#扩展运算符"}},[n._v("#")]),n._v(" 扩展运算符")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("spread扩展运算符\n\nconst pers=['刘德华','孙悟空','猪八戒','沙和尚']\nfunction printperson(){ console.log(arguments) }\nprintperson(...pers)\n---------------------------------------------\n\nfunction  abc(xx){...}\nabc(...[a,b,c])             #相当于python参数的解包，*args，好像没有**kwargs的功能\n")])])]),e("h2",{attrs:{id:"symbol"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#symbol"}},[n._v("#")]),n._v(" Symbol")]),n._v(" "),e("h2",{attrs:{id:"迭代器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#迭代器"}},[n._v("#")]),n._v(" 迭代器")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("1， ES6 创造了一种新的遍历命令 for...of 循环，Iterator 接口主要供 for...of 消费  (默认有for...in的方式可以遍历)\n\n\nconst banji = {\n        name: \"终极一班\",\n        stus: [\n            'xiaoming',\n            'xiaoning',\n            'xiaotian',\n            'knight'\n        ],\n        [Symbol.iterator]() {\n            //索引变量\n            let index = 0;\n            //\n            let _this = this;\n            return {\n                next: function () {\n                    if (index < _this.stus.length) {\n                        const result = { value: _this.stus[index], done: false };\n                        //下标自增\n                        index++;\n                        //返回结果\n                        return result;\n                    }else{\n                        return {value: undefined, done: true};\n                    }\n                }\n            };\n        }\n    }\n    //遍历这个对象 \n    for (let v of banji) {                  #默认情况下是没有for...of方法的\n        console.log(v);\n    }\n")])])]),e("h2",{attrs:{id:"生成器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#生成器"}},[n._v("#")]),n._v(" 生成器")]),n._v(" "),e("h3",{attrs:{id:"示例一"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#示例一"}},[n._v("#")]),n._v(" 示例一")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function * gen(arg){\n    console.log(arg);\n    let one = yield 111;\n    console.log(one);\n    let two = yield 222;\n    console.log(two);\n    let three = yield 333;\n    console.log(three);\n}\n\n\n//执行获取迭代器对象\nlet iterator = gen('AAA');\nconsole.log(iterator.next());        #注意第一次调用的时候并没有传递参数，是在初始化迭代器的时候(上一步时)传递的参数！！！！\n//next方法可以传入实参\nconsole.log(iterator.next('BBB'));    #这个'BBB'是传递的参数，和函数yield 111返回的结果没有关系！！！！！！！\nconsole.log(iterator.next('CCC'));\nconsole.log(iterator.next('DDD'));\n")])])]),e("h3",{attrs:{id:"示例二"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#示例二"}},[n._v("#")]),n._v(" 示例二")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("示例：1s 后控制台输出 111  2s后输出 222  3s后输出 333\n----------------方式一-------------------------\nfunction* gen() {\n    setTimeout(() => {\n        console.log('111');\n        iterator.next()\n    }, 1000);\n    yield;\n    setTimeout(() => {\n        console.log('222');\n        iterator.next()\n    }, 2000);\n    yield;\n    setTimeout(() => {\n        console.log('333');       \n    }, 3000);\n}\nconst iterator = gen();\niterator.next()\n\n\n----------------方式二-------------------------\nfunction f1() { \n    setTimeout(() => {\n        console.log('111');\n        iterator.next()\n    }, 1000);\n}\nfunction f2() { \n    setTimeout(() => {\n        console.log('222');\n        iterator.next()\n    }, 2000);\n}\nfunction f3() {\n    setTimeout(() => {\n        console.log('333');\n        iterator.next()\n    }, 3000);\n}\nfunction* gen() {\n    f1();\n    yield;\n    f2()\n    yield;\n    f3()\n}\n/*\nfunction* gen() {     //视频中使用的时这种调用方式\n    yield f1()\n    yield f2()\n    yield f3()\n}\n*/\nlet iterator = gen()\niterator.next()\n")])])]),e("h3",{attrs:{id:"示例三"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#示例三"}},[n._v("#")]),n._v(" 示例三")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("//模拟获取  用户数据  订单数据  商品数据 \nfunction getUsers(){\n    setTimeout(()=>{\n        let data = '用户数据';\n        //调用 next 方法, 并且将数据传入\n        iterator.next(data);\n    }, 1000);\n}\nfunction getOrders(){\n    setTimeout(()=>{\n        let data = '订单数据';\n        iterator.next(data);\n    }, 1000)\n}\nfunction getGoods(){\n    setTimeout(()=>{\n        let data = '商品数据';\n        iterator.next(data);\n    }, 1000)\n}\nfunction * gen(){\n    let users = yield getUsers();\n    let orders = yield getOrders();\n    let goods = yield getGoods();\n}\n//调用生成器函数\nlet iterator = gen();\niterator.next();\n")])])]),e("h2",{attrs:{id:"promise"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[n._v("#")]),n._v(" Promise")]),n._v(" "),e("h2",{attrs:{id:"set集合"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#set集合"}},[n._v("#")]),n._v(" set集合")]),n._v(" "),e("p",[n._v("ES6 它类似于数组，但成员的值都是唯一的，集合实现了 iterator 接口，所以可以使用『...扩展运算符』和『for…of…』进行遍历，")]),n._v(" "),e("p",[e("strong",[n._v("集合的属性和方法：")])]),n._v(" "),e("ul",[e("li",[n._v("size 返回集合的元素个数")]),n._v(" "),e("li",[n._v("add 增加一个新元素，返回当前集合")]),n._v(" "),e("li",[n._v("delete 删除元素，返回 boolean 值")]),n._v(" "),e("li",[n._v("has 检测集合中是否包含某个元素，返回 boolean 值")]),n._v(" "),e("li",[n._v("clear 清空集合，返回 undefined")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("let s = new Set();\nlet s2 = new Set(['大事儿','小事儿','好事儿','坏事儿','小事儿']);\n//元素个数\n// console.log(s2.size);\n//添加新的元素\n// s2.add('喜事儿');\n//删除元素\n// s2.delete('坏事儿');\n//检测\n// console.log(s2.has('糟心事'));\n//清空\n// s2.clear();\n// console.log(s2);\nfor(let v of s2){\n    console.log(v);\n}\n")])])]),e("h3",{attrs:{id:"示例一-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#示例一-2"}},[n._v("#")]),n._v(" 示例一")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("数组去重\n    let arr = [1,2,3,4,5,4,3,2,1];\n    let result = [...new Set(arr)];\n    \n交集\n    let arr2 = [4,5,6,5,6];\n    let result = [...new Set(arr)].filter(item => new Set(arr2).has(item));\n\n并集\n    let union = [...new Set([...arr, ...arr2])];\n\n差集\n    let diff = [...new Set(arr)].filter(item => !(new Set(arr2).has(item)));\n")])])]),e("h2",{attrs:{id:"map"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[n._v("#")]),n._v(" MAP")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("map就是一个升级版的对象，对象只能以字符串作为键，而map可以将对象作为键  #04:30\n     #下面例子中的 m.set(key, ['北京','上海','深圳'])\n     \n     \nES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合。但是“键”\n的范围不限于字符串，各种类型的值（包括对象）都可以当作键。Map 也实现了\niterator 接口，所以可以使用『扩展运算符』和『for…of…』进行遍历。Map 的属\n性和方法：\n    1) size 返回 Map 的元素个数\n    2) set 增加一个新元素，返回当前 Map\n    3) get 返回键名对象的键值\n    4) has 检测 Map 中是否包含某个元素，返回 boolean 值\n    5) clear 清空集合，返回 undefined\n    \n    \n//声明 Map\nlet m = new Map();\n\n\n//添加元素\nm.set('name','尚硅谷');\nm.set('change', function(){\n    console.log(\"我们可以改变你!!\");\n});\nlet key = {\n    school : 'ATGUIGU'                         #key是一个对象{},key可以是任意字符，如abc\n};\nm.set(key, ['北京','上海','深圳']);            #这种python中能做到么？好像是没有\n\n\n//size\nconsole.log(m.size);\n\n\n//删除\nm.delete('name');\n\n\n//获取\nconsole.log(m.get('change'));\nconsole.log(m.get(key));\n\n\n//清空\nm.clear();\n\n\n//遍历\nfor(let v of m){\n    console.log(v);\n}\n")])])]),e("h2",{attrs:{id:"class"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#class"}},[n._v("#")]),n._v(" class")]),n._v(" "),e("h2",{attrs:{id:"es6的数值扩展"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#es6的数值扩展"}},[n._v("#")]),n._v(" ES6的数值扩展")]),n._v(" "),e("h2",{attrs:{id:"模块化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模块化"}},[n._v("#")]),n._v(" 模块化")]),n._v(" "),e("h2",{attrs:{id:"babel"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#babel"}},[n._v("#")]),n._v(" babel")])])}),[],!1,null,null,null);t.default=s.exports}}]);