(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{421:function(t,e,n){"use strict";n.r(e);var a=n(56),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"创建构造函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#创建构造函数"}},[t._v("#")]),t._v(" 创建构造函数")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Person(name , age , gender){\n    this.name = name;\n    this.age = age;\n    this.gender = gender;\n    this.sayName = function(){\t\t\t#应该不是写在这里的吧？  应该定义在原型链上的吧？\n        alert(this.name);\n    };\n}\n\nvar per = new Person() \n\n\n# 使用instanceof可以检查一个对象是否是一个类的实例，如果是，则返回true，否则返回false：\n    console.log(per instanceof Person);\n    \n# object也是顶级的类，所以任何对象和Object做instanceof检查时都会返回true\n    console.log(per instanceof Object);\n")])])]),n("h2",{attrs:{id:"构造函数修改"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#构造函数修改"}},[t._v("#")]),t._v(" 构造函数修改")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("构造函数每次实例化，sayName函数都会单独开辟一个内存区域，所以需要原型（原型中的函数只会占用一次空间）\nfunction Person(name , age , gender){\n    this.sayName = function(){...};\n}\n\n改为：function fun2(){...} && this.sayName = fun2;\n")])])]),n("h2",{attrs:{id:"原型对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#原型对象"}},[t._v("#")]),t._v(" 原型对象")]),t._v(" "),n("p",[n("strong",[t._v("每一个函数（包括普通函数），解析器都会向函数中添加一个属性prototype，如果函数作为普通函数调用prototype没有任何作用")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function fn1(){\n\tconsole.log('fn1....');\n}\nconsole.log('fn1:',fn1.prototype);\t\t\t\t#普通函数也有prototype属性\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('Person.prototype.a = 10             #类的prototype\np1.__proto__                    \t#实例的__proto__\nPerson.prototype == p1.__proto__\t\t#!!!!!!!!!!!\nPerson.prototype.sayHello = function(){    #这种方法是不是有点傻，只能额外添加不能定义在构造函数中么？？？\n\talert("hello");\n};\n')])])]),n("h3",{attrs:{id:"hasownproperty"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#hasownproperty"}},[t._v("#")]),t._v(" hasOwnProperty")]),t._v(" "),n("p",[t._v("可以使用对象的hasOwnProperty()来检查对象自身中是否含有该属性，使用该方法只有当对象自身中含有属性时，才会返回true")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('#使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true（console.log("name" in mc);）    !!!!!!\n    console.log(mc.hasOwnProperty("age"));\n')])])]),n("h2",{attrs:{id:"tostring"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#tostring"}},[t._v("#")]),t._v(" toString")])])}),[],!1,null,null,null);e.default=s.exports}}]);